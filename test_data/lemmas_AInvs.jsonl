{"input": "lemma st_tcb_at_nostate_upd:\n  \"\\<lbrakk> get_tcb t s = Some y; tcb_state y = tcb_state y' \\<rbrakk> \\<Longrightarrow>\n  st_tcb_at P t' (s \\<lparr>kheap := (kheap s)(t \\<mapsto> TCB y')\\<rparr>) = st_tcb_at P t' s\"", "gt": "lemma st_tcb_at_nostate_upd:\n  \"\\<lbrakk> get_tcb t s = Some y; tcb_state y = tcb_state y' \\<rbrakk> \\<Longrightarrow>\n  st_tcb_at P t' (s \\<lparr>kheap := (kheap s)(t \\<mapsto> TCB y')\\<rparr>) = st_tcb_at P t' s\"\n  by (clarsimp simp add: pred_tcb_at_def obj_at_def dest!: get_tcb_SomeD)"}
{"input": "lemma akernel_invs:\n  \"\\<lbrace>invs and (\\<lambda>s. e \\<noteq> Interrupt \\<longrightarrow> ct_running s)\\<rbrace>\n  (call_kernel e) :: (unit,unit) s_monad\n  \\<lbrace>\\<lambda>rv. invs and (\\<lambda>s. ct_running s \\<or> ct_idle s)\\<rbrace>\"", "gt": "lemma akernel_invs:\n  \"\\<lbrace>invs and (\\<lambda>s. e \\<noteq> Interrupt \\<longrightarrow> ct_running s)\\<rbrace>\n  (call_kernel e) :: (unit,unit) s_monad\n  \\<lbrace>\\<lambda>rv. invs and (\\<lambda>s. ct_running s \\<or> ct_idle s)\\<rbrace>\"\n  unfolding call_kernel_def\n  by (wpsimp wp: activate_invs simp: active_from_running)"}
{"input": "lemma akernel_invs_det_ext:\n  \"\\<lbrace>invs and (\\<lambda>s. e \\<noteq> Interrupt \\<longrightarrow> ct_running s)\\<rbrace>\n  (call_kernel e) :: (unit,det_ext) s_monad\n  \\<lbrace>\\<lambda>rv. invs and (\\<lambda>s. ct_running s \\<or> ct_idle s)\\<rbrace>\"", "gt": "lemma akernel_invs_det_ext:\n  \"\\<lbrace>invs and (\\<lambda>s. e \\<noteq> Interrupt \\<longrightarrow> ct_running s)\\<rbrace>\n  (call_kernel e) :: (unit,det_ext) s_monad\n  \\<lbrace>\\<lambda>rv. invs and (\\<lambda>s. ct_running s \\<or> ct_idle s)\\<rbrace>\"\n  unfolding call_kernel_def\n  by (wpsimp wp: activate_invs simp: active_from_running)"}
{"input": "lemma kernel_entry_invs:\n  \"\\<lbrace>invs and (\\<lambda>s. e \\<noteq> Interrupt \\longrightarrow> ct_running s)\\<rbrace>\n  (kernel_entry e us) :: (user_context,unit) s_monad\n  \\<lbrace>\\<lambda>rv. invs and (\\<lambda>s. ct_running s \\<or> ct_idle s)\\<rbrace>\"", "gt": "lemma kernel_entry_invs:\n  \"\\<lbrace>invs and (\\<lambda>s. e \\<noteq> Interrupt \\longrightarrow> ct_running s)\\<rbrace>\n  (kernel_entry e us) :: (user_context,unit) s_monad\n  \\<lbrace>\\<lambda>rv. invs and (\\<lambda>s. ct_running s \\<or> ct_idle s)\\<rbrace>\"\n  apply (simp add: kernel_entry_def)\n  apply (wp akernel_invs thread_set_invs_trivial thread_set_ct_in_state\n         do_machine_op_ct_in_state hoare_weak_lift_imp hoare_vcg_disj_lift\n      | clarsimp simp add: tcb_cap_cases_def)+\n  done"}
{"input": "lemma device_update_invs:\n  \"\\<lbrace>invs and (\\<lambda>s. (dom ds) \\<subseteq>  (device_region s))\\<rbrace> do_machine_op (device_memory_update ds)\n   \\<lbrace>\\<lambda>_. invs\\<rbrace>\"", "gt": "lemma device_update_invs:\n  \"\\<lbrace>invs and (\\<lambda>s. (dom ds) \\<subseteq>  (device_region s))\\<rbrace> do_machine_op (device_memory_update ds)\n   \\<lbrace>\\<lambda>_. invs\\<rbrace>\"\n  apply (simp add: do_machine_op_def device_memory_update_def simpler_modify_def select_f_def\n                   gets_def get_def bind_def valid_def return_def)\n  apply (clarsimp simp: invs_def valid_state_def valid_irq_states_def valid_machine_state_def\n                        cur_tcb_def pspace_respects_device_region_def cap_refs_respects_device_region_def\n                  cong: user_mem_dom_cong\n              simp del: split_paired_All)\n  apply (clarsimp cong: device_mem_dom_cong simp:cap_range_respects_device_region_def\n              simp del: split_paired_All split_paired_Ex)\n  apply (intro conjI)\n    apply fastforce\n   apply fastforce\n  apply (clarsimp simp del: split_paired_All split_paired_Ex)\n  apply (drule_tac x = \"(a,b)\" in spec)\n  apply (erule notE)\n  apply (erule cte_wp_at_weakenE)\n  apply clarsimp\n  by (fastforce split: if_splits) (* takes 20 secs *)\n\ncrunch user_memory_update\n  for device_state_inv[wp]: \"\\<lambda>ms. P (device_state ms)\""}
{"input": "lemma dom_restrict_plus_eq:\n  \"a \\<inter> b \\<union> b = b\"", "gt": "lemma dom_restrict_plus_eq:\n  \"a \\<inter> b \\<union> b = b\"\n  by auto"}
{"input": "lemma user_memory_update[wp]:\n  \"\\<lbrace>\\<lambda>s. P (device_region s) \\<rbrace> do_machine_op (user_memory_update a)\n   \\<lbrace>\\<lambda>rv s. P (device_region s)\\<rbrace>\"", "gt": "lemma user_memory_update[wp]:\n  \"\\<lbrace>\\<lambda>s. P (device_region s) \\<rbrace> do_machine_op (user_memory_update a)\n   \\<lbrace>\\<lambda>rv s. P (device_region s)\\<rbrace>\"\n  by (simp add: do_machine_op_def user_memory_update_def simpler_modify_def\n                valid_def bind_def gets_def return_def get_def select_f_def)"}
{"input": "lemma do_user_op_invs:\n  \"\\<lbrace>invs and ct_running\\<rbrace>\n   do_user_op f tc\n   \\<lbrace>\\<lambda>_. invs and ct_running\\<rbrace>\"", "gt": "lemma do_user_op_invs:\n  \"\\<lbrace>invs and ct_running\\<rbrace>\n   do_user_op f tc\n   \\<lbrace>\\<lambda>_. invs and ct_running\\<rbrace>\"\n  apply (simp add: do_user_op_def split_def)\n  apply (wp device_update_invs)\n  apply (wp do_machine_op_ct_in_state dmo_invs | simp add:dom_restrict_plus_eq)+\n  apply (clarsimp simp: user_memory_update_def simpler_modify_def\n                        restrict_map_def invs_def cur_tcb_def\n                 split: option.splits if_split_asm)\n  apply (frule ptable_rights_imp_frame)\n     apply fastforce+\n  apply (clarsimp simp: valid_state_def device_frame_in_device_region)\n  done"}
